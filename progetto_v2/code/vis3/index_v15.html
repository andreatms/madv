<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>InfoVis Project</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>

    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        min-height: 100vh;
        background-color: #f5f5f5;
        height: 100%;
        width: 100%;
        margin: 0;
        overflow: hidden;
      }

      .container {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        align-items: flex-start;
        height: calc(100vh - 100px);
        /* Altezza disponibile meno header e footer */
        margin: 0 auto;
        padding: 0;
      }

      header {
        background-color: #3498db;
        padding: 1rem;
        color: white;
      }

      .header {
        text-align: center;
        margin-bottom: 3rem;
      }

      .header h1 {
        color: #2c3e50;
        margin-bottom: 1rem;
      }

      .header p {
        color: #7f8c8d;
        font-size: 1.1rem;
      }

      .back-button {
        position: absolute;
        bottom: 25px;
        left: 25px;
        padding: 8px 15px;
        background-color: #3498db;
        color: white;
        text-decoration: none;
        border-radius: 5px;
        font-size: 14px;
        z-index: 1000;
        transition: background-color 0.2s;
      }

      .back-button:hover {
        background-color: #2980b9;
      }

      svg {
        flex-grow: 1;
        /* Permette all'SVG di occupare lo spazio rimanente */
        background-color: #f5f5f5;
        display: block;
        margin: 0;
        /*border: 2px #2B3E50 solid;*/
        border-radius: 8px;
      }

      .sidebar-element {
        background-color: black;
        color: #f5f5f5;
        width: 200px;
        height: 20px;
      }

      #sidebar-container,
      #ranking-container {
        flex-shrink: 0;
        /* Impedisce che le sidebar si ridimensionino */
        width: 250px;
      }

      #sidebar-container {
        position: absolute;
        top: 200px;
        left: 20px;
        width: 250px;
        padding: 15px;
        background: #2c3e50;
        color: white;
        border-radius: 8px;
        z-index: 1000;
      }

      #ranking-container {
        position: absolute;
        top: 120px;
        right: 20px;
        width: 250px;
        padding: 15px;
        background: #2c3e50;
        color: white;
        border-radius: 8px;
        z-index: 1000;
      }
    </style>
  </head>

  <body>
    <header>
      <h1>Visualizzazione 3</h1>
    </header>

    <footer>
      <a href="../index.html" class="back-button">← Back to Dashboard</a>
    </footer>

    <div class="container"></div>

    <script>
      // Creazione della sidebar
      function createSideBar(data) {
        const sidebar = d3
          .select(".container")
          .append("div")
          .attr("id", "sidebar-container")
          .style("position", "absolute")
          .style("top", "120px")
          .style("left", "20px")
          .style("width", "250px")
          .style("padding", "15px")
          .style("background", "#2c3e50") // Rimuovi la trasparenza
          .style("color", "white")
          .style("border-radius", "8px")
          .style("z-index", "1000");

        const header = sidebar
          .append("div")
          .style("position", "sticky")
          .style("top", "0")
          .style("background", "#2c3e50") // Stesso colore di sfondo del menu
          .style("padding", "10px 0")
          .style("text-align", "center");

        header.append("h3").text("Select ingredient");

        const scrollableContent = sidebar
          .append("div")
          .style("max-height", "calc(70vh - 40px)") // Imposta un'altezza massima per il contenuto scrollabile
          .style("overflow-y", "auto"); // Abilita lo scorrimento verticale

        data.categories.forEach((el) => {
          const button = scrollableContent
            .append("button")
            .text(el)
            .attr("value", 0)
            .attr("id", `category-${el.replace(/\s+/g, "_")}`)
            .attr("class", "sidebar-element")
            .style("display", "flex") // Utilizza flexbox
            .style("align-items", "center") // Centra verticalmente
            .style("justify-content", "center") // Centra orizzontalmente
            .style("width", "100%")
            .style("padding", "20px")
            .style("margin", "5px 0")
            .style("border", "none")
            .style("background", "#3498db")
            .style("border-radius", "6px")
            .style("color", "white")
            .style("cursor", "pointer")
            .on("click", function () {
              scrollableContent
                .select(`#section-${el.replace(/\s+/g, "_")}`)
                .style(
                  "display",
                  scrollableContent
                    .select(`#section-${el.replace(/\s+/g, "_")}`)
                    .style("display") == "block"
                    ? "none"
                    : "block"
                );
            });

          const section = scrollableContent
            .append("div")
            .style("display", "none")
            .attr("id", `section-${el.replace(/\s+/g, "_")}`);

          data.categorized_ingredients.forEach((obj) => {
            if (obj.category == el) {
              section
                .append("button")
                .text(obj.ingredient)
                .attr("class", "ingredient-button")
                .style("display", "flex") // Utilizza flexbox
                .style("align-items", "center") // Centra verticalmente
                .style("justify-content", "center") // Centra orizzontalmente
                .style("width", "90%")
                .style("margin", "3px auto")
                .style("padding", "8px")
                .style(
                  "background",
                  graphData.nodes.some((n) => n.id === obj.ingredient)
                    ? "#e67e22"
                    : "#1abc9c"
                ) // Cambia colore se già nel grafo
                .style("color", "white")
                .style("border", "none")
                .style("border-radius", "4px")
                .style("cursor", "pointer")
                .on("click", function () {
                  //addIngredientToGraph(obj.ingredient);

                  if (graphData.nodes.some((n) => n.id === obj.ingredient)) {
                    removeIngredientFromGraph(obj.ingredient);
                    d3.select(this).style("background", "#1abc9c"); // Cambia colore dopo la rimozione

                    d3.select(`#category-${el.replace(/\s+/g, "_")}`).attr(
                      "value",
                      parseInt(
                        d3
                          .select(`#category-${el.replace(/\s+/g, "_")}`)
                          .attr("value")
                      ) - 1
                    );
                    d3.select(`#category-${el.replace(/\s+/g, "_")}`).text(
                      d3
                        .select(`#category-${el.replace(/\s+/g, "_")}`)
                        .text()
                        .replace(/\(\d+\)/g, "") +
                        `${
                          parseInt(
                            d3
                              .select(`#category-${el.replace(/\s+/g, "_")}`)
                              .attr("value")
                          ) > 0
                            ? " (" +
                              d3
                                .select(`#category-${el.replace(/\s+/g, "_")}`)
                                .attr("value") +
                              ")"
                            : ""
                        }`
                    );
                  } else {
                    addIngredientToGraph(obj.ingredient);
                    d3.select(this).style("background", "#e67e22"); // Cambia colore dopo l'aggiunta

                    d3.select(`#category-${el.replace(/\s+/g, "_")}`).attr(
                      "value",
                      parseInt(
                        d3
                          .select(`#category-${el.replace(/\s+/g, "_")}`)
                          .attr("value")
                      ) + 1
                    );
                    d3.select(`#category-${el.replace(/\s+/g, "_")}`).text(
                      d3
                        .select(`#category-${el.replace(/\s+/g, "_")}`)
                        .text()
                        .replace(/\(\d+\)/g, "") +
                        " (" +
                        d3
                          .select(`#category-${el.replace(/\s+/g, "_")}`)
                          .attr("value") +
                        ")"
                    );
                  }
                });
            }
          });
        });
      }

      // Caricamento dei dati e creazione della sidebar e della classifica
      d3.json("../../data/categorized_ingredients.json")
        .then((data) => {
          const categories = [...new Set(data.map((obj) => obj.category))];
          const categorized_ingredients = data.map((obj) => ({
            category: obj.category,
            ingredient: obj.ingredient,
          }));
          createSideBar({ categories, categorized_ingredients });
          createRankingColumn(); // Crea la colonna per la classifica
        })
        .catch((error) => {
          console.error("Errore nel caricamento dei dati:", error);
        });

      let graphData = { nodes: [], links: [] };
      let svg, g, simulation;
      let zoomBehavior;

      // Inizializzazione del grafo con zoom
      function initializeGraph() {
        const containerWidth = d3
          .select(".container")
          .node()
          .getBoundingClientRect().width;
        const containerHeight = d3
          .select(".container")
          .node()
          .getBoundingClientRect().height;

        svg = d3
          .select(".container")
          .append("svg")
          .attr("width", containerWidth)
          .attr("height", containerHeight);

        // Configura il comportamento dello zoom e salvalo
        zoomBehavior = d3.zoom().on("zoom", (event) => {
          g.attr("transform", event.transform);
        });

        svg.call(zoomBehavior);

        g = svg.append("g");

        simulation = d3
          .forceSimulation()
          .force(
            "link",
            d3
              .forceLink()
              .id((d) => d.id)
              .distance(100)
          )
          .force("charge", d3.forceManyBody().strength(-200))
          .force(
            "center",
            d3.forceCenter(containerWidth / 2, containerHeight / 2)
          );
      }

      // Funzione per aggiornare la visibilità e il raggio dei nodi pasto
      function updateNodeVisibility() {
        const ingredientNodes = graphData.nodes.filter(
          (n) => n.type === "ingredient"
        );

        if (ingredientNodes.length < 2) {
          g.selectAll(".node")
            .style("fill", (d) =>
              d.type === "ingredient" ? "#1abc9c" : "#e74c3c"
            )
            .attr("r", 10); // Reset dimensione nodi pasto
          return;
        }

        // Conta quante connessioni ha ogni pasto
        const mealConnections = {};
        graphData.links.forEach((link) => {
          if (link.target.type === "meal") {
            mealConnections[link.target.id] =
              (mealConnections[link.target.id] || 0) + 1;
          }
        });

        g.selectAll(".node")
          .style("fill", (d) => {
            if (d.type === "ingredient") return "#1abc9c";
            return mealConnections[d.id] === 1 ? "#aaaaaa" : "#e74c3c"; // Grigio per i pasti con un solo ingrediente
          })
          .attr("r", (d) => {
            if (d.type === "meal") {
              return Math.min(10 + (mealConnections[d.id] || 1) * 3, 30); // Raggio massimo 30
            }
            return 10; // Raggio standard ingredienti
          });
      }

      // Funzione per creare la colonna della classifica dei piatti
      function createRankingColumn() {
        const rankingColumn = d3
          .select(".container")
          .append("div")
          .attr("id", "ranking-container")
          .style("display", "none"); // Nascondi inizialmente

        rankingColumn
          .append("h3")
          .text("Top 5 Meals")
          .style("text-align", "center");

        // Aggiungi un elemento vuoto iniziale
        rankingColumn.append("ul").attr("id", "ranking-list");
      }

      // Funzione per aggiornare la classifica dei piatti
      function updateRanking() {
        // Conta il numero di ingredienti per ciascun piatto
        const mealCounts = {};

        graphData.links.forEach((link) => {
          if (link.target.type === "meal") {
            const mealId = link.target.id;
            mealCounts[mealId] = (mealCounts[mealId] || 0) + 1;
          }
        });

        // Ordina i piatti in base al numero di ingredienti selezionati
        const sortedMeals = Object.entries(mealCounts)
          .sort((a, b) => b[1] - a[1]) // Ordina in ordine decrescente
          .slice(0, 5); // Prendi i primi 5 piatti

        const rankingList = d3.select("#ranking-list");
        rankingList.selectAll("*").remove(); // Rimuovi gli elementi precedenti

        // Aggiungi i piatti alla classifica
        sortedMeals.forEach(([meal, count]) => {
          rankingList
            .append("li")
            .text(`${meal} (${count} ingredients)`)
            .style("color", "#1abc9c");
        });

        // Mostra o nascondi la classifica in base alla presenza di nodi "meal"
        if (sortedMeals.length > 0) {
          d3.select("#ranking-container").style("display", "block");
        } else {
          d3.select("#ranking-container").style("display", "none");
        }
      }

      // Funzione per aggiornare il grafo e applicare le modifiche
      function updateGraph() {
        // Aggiorna i link
        const link = g
          .selectAll(".link")
          .data(graphData.links, (d) => `${d.source.id}-${d.target.id}`);

        // Rimuovi i link non più presenti
        link.exit().remove();

        // Aggiungi nuovi link
        link
          .enter()
          .append("line")
          .attr("class", "link")
          .style("stroke", "#999")
          .style("stroke-width", 2);

        // Aggiorna i nodi
        const node = g.selectAll(".node").data(graphData.nodes, (d) => d.id);

        // Rimuovi i nodi non più presenti
        node.exit().remove();

        // Aggiungi nuovi nodi
        const nodeEnter = node
          .enter()
          .append("circle")
          .attr("class", "node")
          .call(
            d3
              .drag()
              .on("start", dragStarted)
              .on("drag", dragged)
              .on("end", dragEnded)
          )
          .on("click", function (event, d) {
            if (d.type === "meal") {
              addRelatedIngredientsToGraph(d.id);
            } else if (d.type === "ingredient") {
              addRelatedMealsToGraph(d.id);
            }
          });

        // Aggiungi tooltip ai nuovi nodi
        nodeEnter.append("title").text((d) => d.id);

        // Assicurati che i nodi siano sempre sopra i link
        g.selectAll(".node").raise();

        // Aggiorna la simulazione
        simulation.nodes(graphData.nodes).on("tick", () => {
          g.selectAll(".link")
            .attr("x1", (d) => d.source.x)
            .attr("y1", (d) => d.source.y)
            .attr("x2", (d) => d.target.x)
            .attr("y2", (d) => d.target.y);

          g.selectAll(".node")
            .attr("cx", (d) => d.x)
            .attr("cy", (d) => d.y);

          drawBoundingBox(); // Disegna la bounding box
          autoZoom();
        });

        simulation.force("link").links(graphData.links);
        simulation.alpha(1).restart();

        updateNodeVisibility(); // Controlla colori e dimensioni dei nodi pasto
        updateRanking(); // Aggiorna la classifica dei piatti
      }

      // Funzione per aggiungere un ingrediente al grafo
      function addIngredientToGraph(selectedIngredient) {
        if (!graphData.nodes.find((n) => n.id === selectedIngredient)) {
          graphData.nodes.push({ id: selectedIngredient, type: "ingredient" });
        }

        const relatedMeals = Object.entries(mealsData).filter(
          ([meal, details]) => details.ingredients.includes(selectedIngredient)
        );

        relatedMeals.forEach(([meal]) => {
          if (!graphData.nodes.find((n) => n.id === meal)) {
            graphData.nodes.push({ id: meal, type: "meal" });
          }

          if (
            !graphData.links.find(
              (l) => l.source.id === selectedIngredient && l.target.id === meal
            )
          ) {
            graphData.links.push({ source: selectedIngredient, target: meal });
          }
        });

        updateGraph();
      }

      function removeIngredientFromGraph(ingredientId) {
        // Rimuovi il nodo corrispondente all'ingrediente
        graphData.nodes = graphData.nodes.filter(
          (node) => node.id !== ingredientId
        );

        // Rimuovi tutti i collegamenti associati al nodo ingrediente
        graphData.links = graphData.links.filter(
          (link) =>
            link.source.id !== ingredientId && link.target.id !== ingredientId
        );

        // Trova i nodi meal isolati (senza collegamenti)
        const connectedNodeIds = new Set(
          graphData.links.flatMap((link) => [link.source.id, link.target.id])
        );
        graphData.nodes = graphData.nodes.filter((node) => {
          // Mantieni solo i nodi che non sono meal isolati
          return node.type !== "meal" || connectedNodeIds.has(node.id);
        });

        // Aggiorna il grafo
        updateGraph();

        // Cambia il colore del pulsante corrispondente nel menu
        d3.selectAll(".ingredient-button")
          .filter(function () {
            return d3.select(this).text() === ingredientId;
          })
          .style("background", "#1abc9c"); // Cambia colore a verde
      }

      // Funzione per aggiungere ingredienti correlati al grafo
      function addRelatedIngredientsToGraph(mealId) {
        const relatedIngredients = mealsData[mealId].ingredients;

        relatedIngredients.forEach((ingredient) => {
          if (!graphData.nodes.find((n) => n.id === ingredient)) {
            graphData.nodes.push({ id: ingredient, type: "ingredient" });
          }

          if (
            !graphData.links.find(
              (l) => l.source.id === ingredient && l.target.id === mealId
            )
          ) {
            graphData.links.push({ source: ingredient, target: mealId });
          }
        });

        updateGraph();
      }

      function addRelatedMealsToGraph(ingredientId) {
        const relatedMeals = Object.entries(mealsData).filter(
          ([meal, details]) => details.ingredients.includes(ingredientId)
        );

        relatedMeals.forEach(([meal]) => {
          if (!graphData.nodes.find((n) => n.id === meal)) {
            graphData.nodes.push({ id: meal, type: "meal" });
          }

          if (
            !graphData.links.find(
              (l) => l.source.id === ingredientId && l.target.id === meal
            )
          ) {
            graphData.links.push({ source: ingredientId, target: meal });
          }
        });

        // Cambia il colore del pulsante corrispondente nel menu
        d3.selectAll(".ingredient-button")
          .filter(function () {
            return d3.select(this).text() === ingredientId;
          })
          .style("background", "#e67e22"); // Cambia colore a arancione

        updateGraph();
      }

      // Funzione di auto-zoom per mantenere il grafo visibile
      function autoZoom() {
        // Calcola i limiti del grafo
        const bounds = {
          minX: Infinity,
          minY: Infinity,
          maxX: -Infinity,
          maxY: -Infinity,
        };

        graphData.nodes.forEach((node) => {
          if (node.x < bounds.minX) bounds.minX = node.x;
          if (node.x > bounds.maxX) bounds.maxX = node.x;
          if (node.y < bounds.minY) bounds.minY = node.y;
          if (node.y > bounds.maxY) bounds.maxY = node.y;
        });

        // Calcola larghezza e altezza del grafo
        const graphWidth = bounds.maxX - bounds.minX;
        const graphHeight = bounds.maxY - bounds.minY;

        // Ottieni le dimensioni dell'SVG
        /*
        const svgWidth = svg.node().getBoundingClientRect().width;
        const svgHeight = svg.node().getBoundingClientRect().height;
        */

        const sidebarWidth =
          d3.select("#sidebar-container").node()?.getBoundingClientRect()
            .width || 0;
        const sidebarHeight =
          d3.select("#sidebar-container").node()?.getBoundingClientRect()
            .height || 0;

        const rankingWidth =
          d3.select("#ranking-container").node()?.getBoundingClientRect()
            .width || 0;
        const rankingHeight =
          d3.select("#ranking-container").node()?.getBoundingClientRect()
            .height || 0;

        const svgWidth = d3.select("svg").attr("width") - sidebarWidth - rankingWidth;
        const svgHeight = d3.select("svg").attr("height");

        // Calcola il fattore di scala per adattare il grafo all'SVG
        const scaleFactor =
          Math.min(svgWidth / graphWidth, svgHeight / graphHeight) * 0.9;

        // Calcola le traslazioni per centrare il grafo
        const translateX =
          (svgWidth - graphWidth * scaleFactor) / 2 - bounds.minX * scaleFactor;
        const translateY =
          (svgHeight - graphHeight * scaleFactor) / 2 -
          bounds.minY * scaleFactor;

        console.log("Graph WH:", graphWidth, graphHeight);
        console.log("SVG WH:", svgWidth, svgHeight);
        console.log("Graph bounds:", bounds);
        console.log("Auto-zoom:", scaleFactor, translateX, translateY);

        
        // Applica la trasformazione con zoom e traslazione
        svg
          .transition()
          .duration(100)
          .call(
            zoomBehavior.transform,
            d3.zoomIdentity.translate(translateX + sidebarWidth, translateY).scale(scaleFactor)
          );
      }

      // Funzione per disegnare la bounding box
      function drawBoundingBox() {
        // Calcola i limiti del grafo
        const bounds = {
          minX: Infinity,
          minY: Infinity,
          maxX: -Infinity,
          maxY: -Infinity,
        };

        graphData.nodes.forEach((node) => {
          if (node.x < bounds.minX) bounds.minX = node.x;
          if (node.x > bounds.maxX) bounds.maxX = node.x;
          if (node.y < bounds.minY) bounds.minY = node.y;
          if (node.y > bounds.maxY) bounds.maxY = node.y;
        });

        // Rimuovi eventuali bounding box precedenti
        g.selectAll(".bounding-box").remove();

        // Aggiungi un rettangolo per la bounding box
        g.append("rect")
          .attr("class", "bounding-box")
          .attr("x", bounds.minX)
          .attr("y", bounds.minY)
          .attr("width", bounds.maxX - bounds.minX)
          .attr("height", bounds.maxY - bounds.minY)
          .style("fill", "none")
          .style("stroke", "red")
          .style("stroke-width", 2)
          .style("stroke-dasharray", "5,5"); // Linea tratteggiata
      }

      // Funzioni per il drag dei nodi
      function dragStarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      }

      function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
      }

      function dragEnded(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
      }

      let mealsData = {};
      Promise.all([
        d3.json("../../data/ingredients.json"),
        d3.json("../../data/meals_corrected.json"),
      ])
        .then(([ingredients, meals]) => {
          mealsData = meals;
          initializeGraph();
        })
        .catch((error) => console.error("Error loading datasets:", error));

      window.addEventListener("resize", () => {
        const containerWidth = d3
          .select(".container")
          .node()
          .getBoundingClientRect().width;
        const sidebarWidth =
          d3.select("#sidebar-container").node()?.getBoundingClientRect()
            .width || 0;
        const rankingWidth =
          d3.select("#ranking-container").node()?.getBoundingClientRect()
            .width || 0;

        const svgWidth = containerWidth - sidebarWidth - rankingWidth - 20; // 20px per margini
        const svgHeight = d3
          .select(".container")
          .node()
          .getBoundingClientRect().height;

        svg.attr("width", svgWidth).attr("height", svgHeight);
        simulation.force("center", d3.forceCenter(svgWidth / 2, svgHeight / 2));
        simulation.alpha(1).restart();
      });
    </script>
  </body>
</html>
