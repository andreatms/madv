<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>InfoVis Project</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        min-height: 100vh;
        background-color: #f5f5f5;
      }

      .container {
        display: flex;
        justify-content: center;
        align-items: center;
        max-width: 1200px;
        margin: 0 auto;
        padding: 0;
      }

      .header {
        text-align: center;
        margin-bottom: 3rem;
      }

      .header h1 {
        color: #2c3e50;
        margin-bottom: 1rem;
      }

      .header p {
        color: #7f8c8d;
        font-size: 1.1rem;
      }

      .back-button {
        position: absolute;
        bottom: 25px;
        left: 25px;
        padding: 8px 15px;
        background-color: #3498db;
        color: white;
        text-decoration: none;
        border-radius: 5px;
        font-size: 14px;
        z-index: 1000;
        transition: background-color 0.2s;
      }

      .back-button:hover {
        background-color: #2980b9;
      }

      .zoom-buttons {
        position: absolute;
        bottom: 250px;
        left: 25px;
        display: flex;
        flex-direction: column;
      }

      .zoom-buttons button {
        padding: 10px 20px;
        margin: 5px 0;
        background-color: #3498db;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.2s;
      }

      .zoom-buttons button:hover {
        background-color: #2980b9;
      }

      #map {
        flex: 1;
        height: 600px;
        /*width: 800px;*/
        background-color: #e0e0e0; /* Set the background color of the map container */
      }

      #barchart {
        width: 200px;
        margin-left: 20px;
      }
      
      .hidden {
        visibility: hidden;
      }
      

      svg {
        background-color: #f5f5f5;
        display: block;
        margin: auto;
      }  

    </style>
  </head>

  <body>
    <header>
      <h1>Visualizzazione 1</h1>
    </header>

    <div class="container">
      <div class="zoom-buttons">
        <button onclick="zoomToRegion('America')">America</button>
        <button onclick="zoomToRegion('Europe')">Europe</button>
        <button onclick="zoomToRegion('Asia')">Asia</button>
        <button onclick="resetView()">Reset View</button>
      </div>
      <div id="map"></div>
      <div id="barchart"></div>
    </div>

    <footer>
      <a href="../index.html" class="back-button">← Back to Dashboard</a>
    </footer>

    <div id="tooltip" style="
      position: absolute;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 14px;
      visibility: hidden;
      pointer-events: none;">
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>


    <script>

      var map = L.map('map', { zoomControl: false }).setView([20, 0], 2);

      /*
      // Aggiungere il layer di base
      var baseLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '&copy; OpenStreetMap contributors'
      }).addTo(map);
      */
      

      // Mappatura manuale tra i nomi dei paesi nei meals e quelli nel GeoJSON
      const countryMapping = {
          "American": "USA",
          "British": "England",
          "Chinese": "China",
          "French": "France",
          "Greek": "Greece",
          "Indian": "India",
          "Italian": "Italy",
          "Japanese": "Japan",
          "Mexican": "Mexico",
          "Spanish": "Spain",
          "Thai": "Thailand"
      };

      // Funzione per ottenere il nome corretto del paese
      function getMappedCountry(mealCountry) {
          return countryMapping[mealCountry] || mealCountry; // Se non mappato, restituisce il nome originale
      }

      // Creare un dizionario per contare i meals per paese
      let mealsByCountry = {};
      let mealsListByCountry = {};
      let ingredientsByCountry = {};

      // Variabile per il layer GeoJSON
      let geoJsonLayer;

      // Caricare i dati GeoJSON delle nazioni e il dataset dei meals
      Promise.all([
          fetch('world.geojson').then(res => res.json()), 
          fetch('../../data/meals.json').then(res => res.json()),
          fetch('../../data/ingredients.json').then(res => res.json())
      ]).then(([geoData, mealsData, ingredientsData]) => {
          

          Object.values(mealsData).forEach(meal => {
              let country = getMappedCountry(meal.area.trim());
              if (country) {
                mealsByCountry[country] = (mealsByCountry[country] || 0) + 1;
                if(ingredientsByCountry[country] == null){
                  ingredientsByCountry[country] = {};
                }
              }
              meal.ingredients.forEach(ingredient => {
                ingredientsByCountry[country][ingredient] = (ingredientsByCountry[country][ingredient] || 0) + 1;
                console.log(ingredientsByCountry[country][ingredient]);
              });
          });
          
          // Funzione per ottenere il colore in base al numero di meals
          function getColor(d) {
              return d > 50 ? '#800026' :
                    d > 30 ? '#BD0026' :
                    d > 20 ? '#E31A1C' :
                    d > 10 ? '#FC4E2A' :
                    d > 5  ? '#FD8D3C' :
                    d > 1  ? '#FEB24C' : "#DCDCDC";
          }
          
          function style(feature) {
              return {
                  fillColor: getColor(mealsByCountry[feature.properties.name] || 0),
                  weight: 1,
                  opacity: 1,
                  color: 'white',
                  fillOpacity: 0.7
                  //fillOpacity: getColor(mealsByCountry[feature.properties.name] || 0) ? 0.7 : 0
              };
          }

          function onEachFeature(feature, layer) {
            let country = feature.properties.name; // Nome del paese nel GeoJSON
            let mealCount = mealsByCountry[country] || 0; // Usa il count o 0 se non esiste
            let mealsList = mealsListByCountry[country] || [];
            
            let popupContent = `<b>${country}</b><br>Meals count: ${mealCount}<br><ul>`;
            
            if (mealsList.length > 0) {
                mealsList.forEach(meal => {
                    popupContent += `<li>${meal}</li>`;
                });
            } 
            popupContent += '</ul>';
            
            layer.bindPopup(popupContent);

            layer.on('click', function(event) {
              updateBarChart(country);
            });
          }

          geoJsonLayer = L.geoJson(geoData, {
              style: style,
              onEachFeature: onEachFeature
          }).addTo(map);
      });


    function updateBarChart(country) {

    // Estrai i primi 5 ingredienti più usati
    let data = Object.entries(ingredientsByCountry[country] || {})
                     .sort((a, b) => b[1] - a[1])  // Ordina per quantità
                     .slice(0, 5); // Prendi i primi 5

    // Seleziona il contenitore del barchart
    let chartContainer = d3.select("#barchart");

    // Se non ci sono dati, esci
    if (data.length === 0){
      //chartContainer.style("display", "none");
      chartContainer.classed("hidden", true);
      map.invalidateSize(); // Aggiorna la mappa per evitare sovrapposizioni
      return;
    } 

    //chartContainer.style("display", "block");
    chartContainer.classed("hidden", false);

    let width = 200, height = 150, margin = { top: 150, right: 30, bottom: 150, left: 100 };

    let svg = chartContainer.html("")
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left},${margin.top})`);

    // **Calcola il massimo solo per il paese selezionato**
    let localMaxIngredientCount = d3.max(data, d => d[1]) || 1; // Evita problemi se vuoto

    // Scale per gli assi
    let x = d3.scaleBand()
              .domain(data.map(d => d[0]))  // Ingredienti
              .range([0, width])
              .padding(0.3);

    let y = d3.scaleLinear()
              .domain([0, localMaxIngredientCount])
              .nice()
              .range([height, 0]);

    // Aggiungere assi X e Y
    svg.append("g")
       .attr("transform", `translate(0,${height})`)
       .call(d3.axisBottom(x))
       .selectAll("text")  // Ruota i nomi degli ingredienti per leggibilità
       .attr("transform", "rotate(-45)")
       .attr("text-anchor", "end")
       .style("font-size", "12px");

    svg.append("g")
       //.call(d3.axisLeft(y));
       .call(d3.axisLeft(y).ticks(6));

    // Seleziona il tooltip
    let tooltip = d3.select("#tooltip");

    // Disegna le barre con eventi mouseover e mouseout
    svg.selectAll("rect")
      .data(data)
      .enter()
      .append("rect")
      .attr("x", d => x(d[0]))
      .attr("y", d => y(d[1]))
      .attr("width", x.bandwidth())
      .attr("height", d => height - y(d[1]))
      .attr("fill", "steelblue")
      .on("mouseover", function(event, d) {
          tooltip.style("visibility", "visible")
                  .text(`${d[0]}: ${d[1]}`) // Mostra il nome dell'ingrediente e la quantità
                  .style("left", (event.pageX + 10) + "px")
                  .style("top", (event.pageY - 20) + "px");
          d3.select(this).attr("fill", "orange"); // Cambia colore per evidenziare
      })
      .on("mousemove", function(event) {
          tooltip.style("left", (event.pageX + 10) + "px")
                  .style("top", (event.pageY - 20) + "px");
      })
      .on("mouseout", function() {
          tooltip.style("visibility", "hidden");
          d3.select(this).attr("fill", "steelblue"); // Ripristina il colore originale
      });

    // **Rimuove qualsiasi listener precedente per evitare duplicati**
    document.removeEventListener("click", hideChart);

    function hideChart(event) {
      let chartContainer = document.querySelector("#barchart");
      
      // Se il click è dentro il barchart o su una nazione, non fare nulla
      if (chartContainer.contains(event.target) || event.target.tagName === "path") {
          return;
      }

      // Altrimenti nascondi il grafico
      //chartContainer.style.display = "none";
      chartContainer.classList.add("hidden");
      map.invalidateSize(); // Aggiorna la mappa per evitare sovrapposizioni
    }

    document.addEventListener("click", hideChart);    

    }

    function zoomToRegion(region) {
      const regions = {
        'America': [50, -110, 3],
        'Europe': [45, 10, 4],
        'Asia': [34.0479, 100.6197, 3.4]
      };

      const [lat, lng, zoom] = regions[region];
      map.setView([lat, lng], zoom);
    }

    function resetView() {
      map.setView([20, 0], 2);
      //baseLayer.addTo(map); // Re-add the base layer to ensure the map is visible
      geoJsonLayer.addTo(map); // Re-add the GeoJSON layer to ensure the map is colored
    }

    </script>

  </body>
</html>
